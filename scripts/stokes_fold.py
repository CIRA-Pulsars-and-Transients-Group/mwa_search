#!/usr/bin/env python3

import logging
import argparse
import sys
import os
import numpy as np

from job_submit import submit_slurm
import config
import data_process_pipeline
import plotting_toolkit
import binfinder

import psrqpy

logger = logging.getLogger(__name__)

#get ATNF db location
try:
    ATNF_LOC = os.environ['PSRCAT_FILE']
except:
    logger.warn("ATNF database could not be loaded on disk. This may lead to a connection failure")
    ATNF_LOC = None

def find_RM_from_cat(pulsar):
    """
    Gets rotation measure from prscat query. Returns None if not on catalogue

    Parameters:
    -----------
    pulsar: str
        The J-name of the pulsar

    Returns:
    --------
    rm: float
        The rotation measure
    rm_err: float
        The uncertainty in the rotation measure
    """

    query = psrqpy.QueryATNF(params=["RM"], psrs=[pulsar], loadfromdb=ATNF_LOC).pandas
    rm = query["RM"][0]
    rm_err = query["RM_ERR"][0]

    if np.isnan(rm):
        return None, None
    elif np.isnan(rm_err):
        rm_err = 0.15*rm
    return rm, rm_err

def find_RM_from_file(fname):
    """
    Finds the rotation measure from an input filename as generated by rmfit.
    Returns Nones if rm cold not be generates.

    Parameters:
    -----------
    fname: str
        The path to the file

    Returns:
    --------
    rm: float
        The rotation measure from the file
    rm_err: float
        The uncertainty in the rotation measure
    """
    f = open(fname)
    lines=f.readlines()
    rm=None
    rm_err=None
    for line in lines:
        line = line.split()
        if line[0] == "Best" and line[1] == "RM":
            rm=float(line[3])
            if len(line) >= 5:
                rm_err=float(line[5])
            else:
                logger.warn("Uncertainty for RM not available")
                rm_err=None
            break

    if not rm:
        logger.warn("RM could not be generated from archive file")

    return rm, rm_err

#def submit_RM()
    #This is not implemented in the pulsar databse yet

def submit_dspsr(run_params, dspsr_ops=''):
    """
    Runs dspsr on fits files and relaunches the stokes fold script

    Parameters:
    -----------
    run_params: object
        The run_params object from data_process_pipeline.py
    """

    if dspsr_ops!='':
        logger.info("dspsr custom options: {}".format(dspsr_ops))

    launch_line = "stokes_fold.py -m f -d {0} -p {1} -b {2} -s {3} -o {4} -L {5} -f {6}\
                    --mwa_search {7} --vcs_tools {8} --beg {9} --end {10}"\
                    .format(run_params.pointing_dir, run_params.pulsar, run_params.stokes_bins,\
                    run_params.subint, run_params.obsid, run_params.loglvl, run_params.freq,\
                    run_params.mwa_search, run_params.vcs_tools, run_params.beg, run_params.end)
    if run_params.stop==True:
        launch_line += " -S"

    enter, leave, _ = binfinder.find_fold_times\
                      (run_params.pulsar, run_params.obsid, run_params.beg, run_params.end, min_z_power=[0.3, 0.1])
    if not enter or not leave:
        logger.warn("{} not in beam for given times. Will use entire integration time to fold.".format(run_params.pulsar))
    duration = run_params.end - run_params.beg
    enter_sec = enter*duration
    leave_sec = leave*duration

    file_name = "{0}_subint_{1}".format(run_params.pulsar, run_params.subint)
    dspsr_ops += " {0}/*.fits".format(run_params.pointing_dir)
    dspsr_ops += " -O {}".format(os.path.join(run_params.pointing_dir, file_name))
    dspsr_ops += " -b {}".format(run_params.stokes_bins)
    dspsr_ops += " -E {}.eph".format(os.path.join(run_params.pointing_dir, run_params.pulsar))
    dspsr_ops += " -L {}".format(run_params.subint)
    dspsr_ops += " -S {}".format(enter_sec)
    dspsr_ops += " -T {}".format(leave_sec - enter_sec)

    commands=[]
    commands.append("cd {}".format(run_params.pointing_dir))
    commands.append("psrcat -e {1} > {0}/{1}.eph".format(run_params.pointing_dir, run_params.pulsar))
    commands.append("echo 'Running DSPSR folding...'\n")
    commands.append("dspsr -cont -U 4000 -A -K {}".format(dspsr_ops))
    commands.append("echo 'Attempting to find rotation measure.\nOutputting result to {0}/{1}_rmfit.txt'\n"\
                    .format(run_params.pointing_dir, run_params.pulsar))
    commands.append("rmfit {0}_subint_{1}.ar -t > {0}_rmfit.txt"\
                    .format(run_params.pulsar, run_params.subint))

    #rerun the script
    commands.append(launch_line)

    name = "dspsr_RM_{0}_{1}".format(run_params.pulsar, run_params.obsid)
    comp_config = config.load_config_file()
    batch_dir = "{}".format(os.path.join(comp_config['base_product_dir'], run_params.obsid, "batch"))
    submit_slurm(name, commands,\
                batch_dir=batch_dir,\
                slurm_kwargs={"time": "08:00:00"},\
                module_list=["mwa_search/{0}".format(run_params.mwa_search),\
                            "dspsr/master", "psrchive/master"],\
                submit=True, vcstools_version=run_params.vcs_tools, mem="")

    logger.info("Job submitted for dspsr using\n\
                pointing directory:         {0}\n\
                pulsar:                     {1}"\
                .format(run_params.pointing_dir, run_params.pulsar))

def submit_RM_correct(run_params):
    """
    Runs the RM correction on the dspsr archive and writes the result to a text file.
    Relaunches the stokes_fold script afterwards for plotting

    Parameters:
    -----------
    run_params: object
        The run_params object from data_process_pipeline.py
    """

    launch_line = "stokes_fold.py -m p -d {0} -p {1} -b {2} -s {3} -o {4} -L {5} -f {6}\
                    --mwa_search {7} --vcs_tools {8} --beg {9} --end {10}"\
                    .format(run_params.pointing_dir, run_params.pulsar, run_params.stokes_bins,\
                     run_params.subint, run_params.obsid, run_params.loglvl, run_params.freq,\
                    run_params.mwa_search, run_params.vcs_tools, run_params.beg, run_params.end)

    if run_params.stop==True:
        launch_line += " -S"

    commands = []
    #correct for RM
    commands.append("cd {}".format(run_params.pointing_dir))
    commands.append("echo 'Correcting for input rotation measure'\n")
    commands.append("pam -e ar2 -R {0} {1}_subint_{2}.ar"\
    .format(run_params.RM, run_params.pulsar, run_params.subint))
    #Turn the archive into a readable ascii file
    commands.append("echo 'Wiritng result to text file'\n")
    commands.append("pdv -FTt {0}_subint_{1}.ar2 > {0}_archive.txt".\
    format(run_params.pulsar, run_params.subint))
    #RVM fitting
    commands.append("echo 'Fitting RVM'\n")
    commands.append("psrmodel *.ar2 -resid -psi-resid -use_beta -s 18X18 &> {0}_{1}_RVM_fit.txt > {0}_{1}_chi_map.txt"\
        .format(run_params.obsid, run_params.pulsar))

    #launch plotting
    commands.append(launch_line)

    name = "RMcor_plt_{0}_{1}".format(run_params.pulsar, run_params.obsid)
    comp_config = config.load_config_file()
    batch_dir = "{0}{1}/batch/".format(comp_config['base_product_dir'],
                                       run_params.obsid)
    submit_slurm(name, commands,\
                batch_dir=batch_dir,\
                slurm_kwargs={"time": "03:00:00"},\
                module_list=["mwa_search/{0}".format(run_params.mwa_search),
                            "psrchive/master"],\
                submit=True, vcstools_version=run_params.vcs_tools, mem="")


if __name__ == '__main__':
    #dictionary for choosing log-levels
    loglevels = dict(DEBUG=logging.DEBUG,
                     INFO=logging.INFO,
                     WARNING=logging.WARNING,
                     ERROR = logging.ERROR)

    #Arguments
    parser = argparse.ArgumentParser(description="""Folds across stokes IQUV and attempts to find the RM""")

    foldop = parser.add_argument_group("Folding Options:")
    foldop.add_argument("-d", "--pointing_dir", type=str, help="Pointing directory that contains the fits files")
    foldop.add_argument("-p", "--pulsar", type=str, default=None, help="The name of the pulsar. If not provided, the script will try to get the pulsar from the pointing directory")
    foldop.add_argument("-b", "--nbins", type=int, help="The number of bins to fold the profile with")
    foldop.add_argument("-s", "--subint", type=float, default=10.0, help="The length of the integrations in seconds. Default: 10.0")
    foldop.add_argument("-o", "--obsid", type=str, help="The obsid of the observation")
    foldop.add_argument("--beg", type=int, help="The beginning of the observation time in gps time")
    foldop.add_argument("--end", type=int, help="The end of the observation time in gps time")
    foldop.add_argument("--dspsr_ops", type=str, default="", help="Provide as a string in quotes any dspsr command you would like to use for folding.\
                        eg: '-D 50.0 -c 506.25'. Defualt=''")

    otherop = parser.add_argument_group("Other Options:")
    otherop.add_argument("-L", "--loglvl", type=str, default="INFO", help="Logger verbosity level. Default: INFO", choices=loglevels.keys())
    otherop.add_argument("--vcs_tools", type=str, default="master", help="The version of vcstools to use. Default: master")
    otherop.add_argument("--mwa_search", type=str, default="master", help="The version of mwa_search to use. Default: master")
    otherop.add_argument("-S", "--stop", action="store_false", help="Use this tag to stop processing data after the chose mode has finished its intended purpose")
    otherop.add_argument("-f", "--freq", type=float, help="The central frequency of the observation in MHz")
    otherop.add_argument("--nocrop", action="store_true", help="Use this tag to force no cropping of the profile")

    modeop = parser.add_argument_group("Mode Options:")
    modeop.add_argument("-m", "--mode", type=str, help="The mode in which to run stokes_fold: \n\
                        'i' - Creates a dspsr archive and runs rmfit and outputs the result\n\
                        'f' - Reads an RMfit output and corrects the archive for RM. Then creates\
                        an ascii text file\n\
                        'p' - Plots a dspsr ascii text file")

    args = parser.parse_args()

    logger.setLevel(loglevels[args.loglvl])
    ch = logging.StreamHandler()
    ch.setLevel(loglevels[args.loglvl])
    formatter = logging.Formatter('%(asctime)s  %(filename)s  %(name)s  %(lineno)-4d  %(levelname)-9s :: %(message)s')
    ch.setFormatter(formatter)
    logger.addHandler(ch)
    logger.propagate = False

    if not args.nbins:
        logger.error("Please input an argument for the number of bins to use")
        sys.exit(1)
    if not args.pulsar:
        logger.error("Pulsar name not supplied. Please run again and specify puslar name")
        sys.exit(1)
    if not args.pointing_dir:
        logger.error("Pointing directory not supplied. Please run again and specify a pointing directory")
        sys.exit(1)
    if not args.obsid:
        logger.error("Obsid not supplied. Please run again and specify a pointing directory")
        sys.exit(1)
    if not args.beg or not args.end:
        logger.error("Beginning/end times not supplied. Please run again and specify times")
        sys.exit(1)

    run_params = data_process_pipeline.run_params_class(pointing_dir=args.pointing_dir,\
                pulsar=args.pulsar, stokes_bins=args.nbins, loglvl=args.loglvl, subint=args.subint,\
                mode=args.mode, vcs_tools=args.vcs_tools, mwa_search=args.mwa_search,\
                obsid=args.obsid, stop=args.stop, freq=args.freq, nocrop=args.nocrop, beg=args.beg,\
                end=args.end)

    if run_params.mode == "i":
        submit_dspsr(run_params, args.dspsr_ops)

    elif run_params.mode == "f":
        fname = os.path.join(run_params.pointing_dir, "{0}_rmfit.txt".format(run_params.pulsar))
        RM, RM_err = find_RM_from_file(fname)
        if RM is None:
            RM, RM_err = find_RM_from_cat(run_params.pulsar)

        if RM is not None:
            logger.info("Submitting RM correction and plot script for RM: {0}".format(RM))
            run_params.set_RM_and_err(RM, RM_err)
            submit_RM_correct(run_params)
        else:
            logger.info("RM could not be generated and is not found on record. Cannot proceed")

    elif run_params.mode == "p":
        logger.info("Plotting dspsr archive in {}".format(run_params.pointing_dir))
        fname = os.path.join(run_params.pointing_dir, "{}_archive.txt".format(run_params.pulsar))
        fig_name = plotting_toolkit.plot_archive_stokes(fname, obsid=run_params.obsid, pulsar=run_params.pulsar,\
                            freq=run_params.freq, out_dir=run_params.pointing_dir)
    else:
        logger.error("Unrecognised mode. Please rerun with a suitable mode selected")
        sys.exit(1)
